# Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import os
import subprocess
from pathlib import Path

from nvflare.lighter.constants import ProvFileName
from nvflare.lighter.ctx import ProvisionContext
from nvflare.lighter.entity import Participant, Project
from nvflare.lighter.spec import Packager

BUILD_IMAGE_CMD = "build_cvm_image.sh"


def update_log_filenames(config, new_log_root: str = "/applog"):
    handlers = config.get("handlers", {})
    for handler_name, handler_cfg in handlers.items():
        filename = handler_cfg.get("filename")
        if filename:
            handler_cfg["filename"] = os.path.join(new_log_root, filename)
    return config


def run_command(command, cwd=None):
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            capture_output=True,
            text=True,
            check=True,  # Raises CalledProcessError on non-zero return
        )
        print(f"Process succeeded with return code {result.returncode}")
        print(f"STDOUT:\n{result.stdout}")
        print(f"STDERR:\n{result.stderr}")

    except subprocess.CalledProcessError as e:
        print(f"Process failed with return code {e.returncode}")
        print(f"STDOUT:\n{e.stdout}")
        print(f"STDERR:\n{e.stderr}")


class OnPremPackager(Packager):
    def __init__(self, cc_config_key="cc_config", build_image_cmd=BUILD_IMAGE_CMD):
        super().__init__()
        self.cc_config_key = cc_config_key
        self.build_image_cmd = build_image_cmd

    def _build_cc_image(self, cc_config_yaml: str, site_name: str, startup_folder_path: str):
        """Build CC image for the site."""
        print(f"calling {self.build_image_cmd=} {cc_config_yaml=} {site_name=} {startup_folder_path=}")
        cc_config_yaml = os.path.abspath(cc_config_yaml)
        command = [self.build_image_cmd, cc_config_yaml, site_name, startup_folder_path]
        run_command(command)

    def _change_log_dir(self, log_config_path: str):
        with open(log_config_path, "r") as f:
            config = json.load(f)

        updated_config = update_log_filenames(config)

        with open(log_config_path, "w") as f:
            json.dump(updated_config, f, indent=4)

    def _build_docker_image(self, participant: Participant, dest_dir: str):
        command = ["sudo", "/bin/bash", f"{dest_dir}/{participant.name}/docker_build.sh"]
        run_command(command, cwd=f"{dest_dir}/{participant.name}")

    def _package_for_participant(self, participant: Participant, ctx: ProvisionContext):
        """Package the startup kit for the participant."""
        if not participant.get_prop(self.cc_config_key):
            return

        dest_dir = Path(ctx.get_result_location())
        # Build docker image for each
        self._build_docker_image(participant, dest_dir)
        # Build CC image
        self._build_cc_image(participant.get_prop(self.cc_config_key), participant.name, dest_dir)

        # TODO: Package the scripts generated by the build_cvm_image.sh

        log_config_path = dest_dir / participant.name / "local" / ProvFileName.LOG_CONFIG_DEFAULT
        self._change_log_dir(log_config_path)

    def package(self, project: Project, ctx: ProvisionContext):
        for p in project.get_all_participants():
            self._package_for_participant(p, ctx)
