VM_NAME=nvflare_dashboard
AMI_IMAGE=ami-04c7330a29e61bbca # 22.04 from https://cloud-images.ubuntu.com/locator/ec2/
EC2_TYPE=t2.small
SECURITY_GROUP=nvflare_dashboard_sg_$RANDOM
REGION=us-west-2
ADMIN_USERNAME=ubuntu
DEST_FOLDER=/home/${ADMIN_USERNAME}
KEY_PAIR=NVFlareDashboardKeyPair
KEY_FILE=${KEY_PAIR}.pem

echo "This script requires aws (AWS CLI), sshpass, dig and jq.  Now checking if they are installed."

check_binary aws "Please see https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html on how to install it on your system."
check_binary sshpass "Please install it first."
check_binary dig "Please install it first."
check_binary jq "Please install it first."

if [ -z ${vpc_id+x} ]
then
    using_default_vpc=true
else
    using_default_vpc=false
fi

echo "One initial user will be created when starting dashboard."
echo "Please enter the email address for this user."
read email
echo "Please enter the organization name of this person."
read org_name
credential="${email}:$RANDOM:${org_name}"

# Generate key pair

echo "Generating key pair for VM"

aws ec2 delete-key-pair --key-name $KEY_PAIR > /dev/null 2>&1
rm -rf $KEY_FILE
aws ec2 create-key-pair --key-name $KEY_PAIR --query 'KeyMaterial' --output text > $KEY_FILE
report_status "$?" "creating key pair"
chmod 400 $KEY_FILE

# Check if default VPC exists
if [ $using_default_vpc == true ]
then
  echo "Checking if default VPC exists"
  found_default_vpc=$(aws ec2 describe-vpcs | jq '.Vpcs[] | select(.IsDefault == true)')
  if [ -z "${found_default_vpc}" ]
  then
    echo "No default VPC found.  Please create one before running this script with the following command."
    echo "aws ec2 create-default-vpc"
    echo "or specify your own vpc and subnet with --vpc-id and --subnet-id"
    exit
  else
    echo "Default VPC found"
  fi
else
  echo "Please check the vpc-id $vpc_id and subnet-id $subnet_id are correct and they support EC2 with public IP and internet gateway with proper routing."
  echo "This script will use the above info to create EC2 instance."
fi

# Generate Security Group
# Try not reusing existing security group because we have to modify it for our own need.
if [ $using_default_vpc == true ]
then
  sg_id=$(aws ec2 create-security-group --group-name $SECURITY_GROUP --description "NVFlare security group" | jq -r .GroupId)
else
  sg_id=$(aws ec2 create-security-group --group-name $SECURITY_GROUP --description "NVFlare security group" --vpc-id $vpc_id | jq -r .GroupId)
fi
report_status "$?" "creating security group"
echo "Security group id: ${sg_id}"
my_public_ip=$(dig +short myip.opendns.com @resolver1.opendns.com)
if [ "$?" -eq 0 ] && [[ "$my_public_ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
then
  aws ec2 authorize-security-group-ingress --group-id $sg_id --protocol tcp --port 22 --cidr ${my_public_ip}/32 > /tmp/sec_grp.log
else
  echo "getting my public IP failed, please manually configure the inbound rule to limit SSH access"
  aws ec2 authorize-security-group-ingress --group-id $sg_id --protocol tcp --port 22 --cidr 0.0.0.0/0 > /tmp/sec_grp.log
fi
aws ec2 authorize-security-group-ingress --group-id $sg_id --protocol tcp --port 443 --cidr 0.0.0.0/0 >> /tmp/sec_grp.log
report_status "$?" "creating security group rules"

# Start provisioning

echo "Creating VM at region ${REGION}, may take a few minutes."
if [ $using_default_vpc == true ]
then
  aws ec2 run-instances --region ${REGION} --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id > vm_create.json
else
  aws ec2 run-instances --region ${REGION} --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id --subnet-id $subnet_id > vm_create.json
fi
report_status "$?" "creating VM"
instance_id=$(jq -r .Instances[0].InstanceId vm_create.json)

aws ec2 wait instance-status-ok --instance-ids $instance_id
aws ec2 describe-instances --instance-ids $instance_id > vm_result.json

IP_ADDRESS=$(jq -r .Reservations[0].Instances[0].PublicIpAddress vm_result.json)

echo "VM created with IP address: ${IP_ADDRESS}"

echo "Installing docker engine in $VM_NAME, may take a few minutes."
DEST_SITE=${ADMIN_USERNAME}@${IP_ADDRESS}
scripts=$(cat << 'EOF'
sudo apt-get update && \
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ca-certificates curl gnupg lsb-release && \
sudo mkdir -p /etc/apt/keyrings && \
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg && \
echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && \
sudo apt-get update && \
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y docker-ce docker-ce-cli containerd.io
EOF
)
ssh -t -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} "$scripts" > /tmp/docker_engine.log
report_status "$?" "installing docker engine"
ssh -t -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} "sudo usermod -aG docker $ADMIN_USERNAME && exit" >> /tmp/docker_engine.log
report_status "$?" "installing docker engine"

echo "Installing nvflare in $VM_NAME, may take a few minutes."
ssh -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} \
  "export PATH=/home/ubuntu/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin && \
  wget -q https://bootstrap.pypa.io/get-pip.py && python3 get-pip.py && \
  python3 -m pip install {{ NVFLARE }} && \
  mkdir -p ./cert && \
  exit" > /tmp/nvflare.json
report_status "$?" "installing nvflare"

echo "Checking if certificate (web.crt) and private key (web.key) are available"
if [[ -f "web.crt" && -f "web.key" ]]; then
  CERT_FOLDER=${DEST_SITE}:${DEST_FOLDER}/cert
  echo "Cert folder is ${CERT_FOLDER}"
  scp -i $KEY_FILE -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null web.{crt,key} $CERT_FOLDER
  report_status "$?" "copying cert/key to VM ${CERT_FOLDER} folder"
  secure=true
else
  echo "No web.crt and web.key found"
  secure=false
fi

echo "Starting dashboard"
ssh -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} \
  "export PATH=/home/ubuntu/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin && \
  python3 -m nvflare.dashboard.cli --start -f ${DEST_FOLDER} --cred ${credential} {{ START_OPT }}" > /tmp/dashboard.json

echo "Dashboard url is running at IP address ${IP_ADDRESS}, listening to port 443."
if [ "$secure" == true ]
then
  echo "URL is https://${IP_ADDRESS}"
else
  echo "URL is http://${IP_ADDRESS}:443"
fi
echo "Note: you may need to configure DNS server with your DNS hostname and the above IP address."
echo "Project admin credential (username:password:organization) is ${credential} ."
echo "To terminate the EC2 instance, run the following command."
echo "aws ec2 terminate-instances --instance-ids ${instance_id}"
echo "Other resources provisioned"
echo "security group: ${SECURITY_GROUP}"
echo "key pair: ${KEY_PAIR}"
